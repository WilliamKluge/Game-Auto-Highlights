import cv2
import numpy
import math
from enum import Enum


class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """

    def __init__(self, mask):
        """initializes all values to presets or None if need to be set
        """

        # Step Desaturate0:
        self.__mask_mask = self.__desaturate(mask)

        self.mask_output = None

        self.__rgb_threshold_input = self.mask_output
        # self.__rgb_threshold_red = [60, 130]
        # self.__rgb_threshold_green = [170, 255.0]
        # self.__rgb_threshold_blue = [225, 255.0]
        self.__rgb_threshold_red = [50, 255]
        self.__rgb_threshold_green = [50, 255.0]
        self.__rgb_threshold_blue = [50, 255.0]

        self.rgb_threshold_output = None

        self.__find_contours_input = self.rgb_threshold_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """

        # Step Mask0:
        self.__mask_input = source0
        (self.mask_output) = self.__mask(self.__mask_input, self.__mask_mask)

        # Step RGB_Threshold0:
        self.__rgb_threshold_input = self.mask_output
        (self.rgb_threshold_output) = self.__rgb_threshold(self.__rgb_threshold_input, self.__rgb_threshold_red,
                                                           self.__rgb_threshold_green, self.__rgb_threshold_blue)

        # Step Find_Contours0:
        self.__find_contours_input = self.rgb_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input,
                                                           self.__find_contours_external_only)

    @staticmethod
    def __desaturate(src):
        """Converts a color image into shades of gray.
        Args:
            src: A color numpy.ndarray.
        Returns:
            A gray scale numpy.ndarray.
        """
        (a, b, channels) = src.shape
        if (channels == 1):
            return numpy.copy(src)
        elif (channels == 3):
            return cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)
        elif (channels == 4):
            return cv2.cvtColor(src, cv2.COLOR_BGRA2GRAY)
        else:
            raise Exception("Input to desaturate must have 1, 3 or 4 channels")

    @staticmethod
    def __mask(input, mask):
        """Filter out an area of an image using a binary mask.
        Args:
            input: A three channel numpy.ndarray.
            mask: A black and white numpy.ndarray.
        Returns:
            A three channel numpy.ndarray.
        """
        return cv2.bitwise_and(input, input, mask=mask)

    @staticmethod
    def __rgb_threshold(input, red, green, blue):
        """Segment an image based on color ranges.
        Args:
            input: A BGR numpy.ndarray.
            red: A list of two numbers the are the min and max red.
            green: A list of two numbers the are the min and max green.
            blue: A list of two numbers the are the min and max blue.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2RGB)
        return cv2.inRange(out, (red[0], green[0], blue[0]), (red[1], green[1], blue[1]))

    @staticmethod
    def __find_contours(input_data, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input_data: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """

        if (external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        im2, contours, hierarchy = cv2.findContours(input_data, mode=mode, method=method)
        return contours
